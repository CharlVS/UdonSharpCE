using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEngine;

namespace UdonSharp.CE.Editor.GraphBridge
{
    /// <summary>
    /// Generates UdonSharp wrapper code from [GraphNode] decorated methods.
    /// Creates type-safe, Udon-compatible wrapper classes that can be used in UdonSharpBehaviours.
    /// </summary>
    public static class GraphNodeCodeGenerator
    {
        #region Constants

        private const string OUTPUT_FOLDER = "Assets/UdonSharpCE/GeneratedWrappers";
        private const string NAMESPACE = "UdonSharp.CE.Generated";

        #endregion

        #region Public Methods

        /// <summary>
        /// Generates wrapper code for all discovered graph nodes.
        /// </summary>
        [MenuItem("Udon CE/Graph Bridge/Generate Wrappers", false, 1504)]
        public static void GenerateAllWrappers()
        {
            var nodes = GraphNodeGenerator.GetNodeDefinitions();

            if (nodes.Count == 0)
            {
                Debug.Log("[GraphNodeCodeGenerator] No graph nodes found to generate wrappers for.");
                return;
            }

            EnsureOutputFolder();

            // Group nodes by category
            var nodesByCategory = GroupNodesByCategory(nodes);

            int generatedCount = 0;

            foreach (var kvp in nodesByCategory)
            {
                string category = kvp.Key;
                var categoryNodes = kvp.Value;

                string fileName = SanitizeFileName(category) + "Nodes.cs";
                string filePath = Path.Combine(OUTPUT_FOLDER, fileName);

                string code = GenerateCategoryClass(category, categoryNodes);
                File.WriteAllText(filePath, code);
                generatedCount++;
            }

            AssetDatabase.Refresh();
            Debug.Log($"[GraphNodeCodeGenerator] Generated {generatedCount} wrapper files with {nodes.Count} methods in {OUTPUT_FOLDER}");
        }

        /// <summary>
        /// Generates a wrapper for a single node.
        /// </summary>
        public static void GenerateWrapper(NodeDefinition node)
        {
            if (node?.Method == null)
            {
                Debug.LogWarning("[GraphNodeCodeGenerator] Cannot generate wrapper for null node or node without method.");
                return;
            }

            EnsureOutputFolder();

            string category = GetCategory(node.MenuPath);
            string fileName = SanitizeFileName(category) + "_" + node.Method.Name + ".cs";
            string filePath = Path.Combine(OUTPUT_FOLDER, fileName);

            string code = GenerateSingleNodeWrapper(node);
            File.WriteAllText(filePath, code);

            AssetDatabase.Refresh();
            Debug.Log($"[GraphNodeCodeGenerator] Generated wrapper at {filePath}");
        }

        /// <summary>
        /// Generates example usage code for a node.
        /// </summary>
        public static string GenerateExampleUsage(NodeDefinition node)
        {
            if (node?.Method == null)
                return "// No method available";

            var sb = new StringBuilder();

            sb.AppendLine("// Example usage:");

            // Build the call
            if (node.Method.ReturnType != typeof(void))
            {
                sb.Append($"{GetTypeName(node.Method.ReturnType)} result = ");
            }

            if (node.Method.IsStatic)
            {
                sb.Append($"{node.ContainingType?.Name ?? "Unknown"}.");
            }
            else
            {
                sb.Append("instance.");
            }

            sb.Append($"{node.Method.Name}(");

            var parameters = node.Method.GetParameters()
                .Where(p => !p.IsOut)
                .ToList();

            for (int i = 0; i < parameters.Count; i++)
            {
                if (i > 0) sb.Append(", ");
                sb.Append(GetDefaultValueString(parameters[i].ParameterType));
            }

            sb.AppendLine(");");

            return sb.ToString();
        }

        #endregion

        #region Code Generation

        private static string GenerateCategoryClass(string category, List<NodeDefinition> nodes)
        {
            var sb = new StringBuilder();

            // Header
            sb.AppendLine("// =============================================================================");
            sb.AppendLine("// AUTO-GENERATED CODE - DO NOT MODIFY");
            sb.AppendLine($"// Generated by UdonSharpCE GraphNodeCodeGenerator");
            sb.AppendLine($"// Category: {category}");
            sb.AppendLine($"// Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine("// =============================================================================");
            sb.AppendLine();

            // Usings
            sb.AppendLine("using System;");
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using VRC.SDKBase;");
            sb.AppendLine("using UdonSharp;");
            sb.AppendLine();

            // Namespace
            sb.AppendLine($"namespace {NAMESPACE}");
            sb.AppendLine("{");

            // Class
            string className = SanitizeIdentifier(category) + "Nodes";
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Generated wrapper methods for {category} graph nodes.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static class {className}");
            sb.AppendLine("    {");

            // Generate methods
            foreach (var node in nodes)
            {
                if (node.Method == null) continue;

                sb.AppendLine();
                GenerateMethod(sb, node);
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static string GenerateSingleNodeWrapper(NodeDefinition node)
        {
            var sb = new StringBuilder();

            // Header
            sb.AppendLine("// =============================================================================");
            sb.AppendLine("// AUTO-GENERATED CODE - DO NOT MODIFY");
            sb.AppendLine($"// Generated by UdonSharpCE GraphNodeCodeGenerator");
            sb.AppendLine($"// Node: {node.MenuPath}");
            sb.AppendLine($"// Generated: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
            sb.AppendLine("// =============================================================================");
            sb.AppendLine();

            // Usings
            sb.AppendLine("using System;");
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using VRC.SDKBase;");
            sb.AppendLine("using UdonSharp;");
            sb.AppendLine();

            // Namespace
            sb.AppendLine($"namespace {NAMESPACE}");
            sb.AppendLine("{");

            // Class
            string className = SanitizeIdentifier(node.Method.Name) + "Wrapper";
            sb.AppendLine($"    /// <summary>");
            sb.AppendLine($"    /// Generated wrapper for {node.MenuPath}.");
            sb.AppendLine($"    /// </summary>");
            sb.AppendLine($"    public static class {className}");
            sb.AppendLine("    {");

            sb.AppendLine();
            GenerateMethod(sb, node);

            sb.AppendLine("    }");
            sb.AppendLine("}");

            return sb.ToString();
        }

        private static void GenerateMethod(StringBuilder sb, NodeDefinition node)
        {
            var method = node.Method;

            // XML Documentation
            sb.AppendLine($"        /// <summary>");
            sb.AppendLine($"        /// {node.Tooltip ?? node.MenuPath}");
            sb.AppendLine($"        /// </summary>");

            // Document parameters
            foreach (var input in node.Inputs)
            {
                string tooltip = input.Tooltip ?? $"Input: {input.Name}";
                sb.AppendLine($"        /// <param name=\"{SanitizeIdentifier(input.Name)}\">{tooltip}</param>");
            }

            // Document return
            if (method.ReturnType != typeof(void))
            {
                sb.AppendLine($"        /// <returns>The result of the operation.</returns>");
            }

            // Method signature
            string returnType = GetTypeName(method.ReturnType);
            string methodName = method.Name;

            sb.Append($"        public static {returnType} {methodName}(");

            // Parameters
            var parameters = method.GetParameters();
            for (int i = 0; i < parameters.Length; i++)
            {
                if (i > 0) sb.Append(", ");

                var param = parameters[i];
                if (param.IsOut)
                    sb.Append("out ");
                else if (param.ParameterType.IsByRef)
                    sb.Append("ref ");

                Type paramType = param.ParameterType.IsByRef
                    ? param.ParameterType.GetElementType()
                    : param.ParameterType;

                sb.Append($"{GetTypeName(paramType)} {SanitizeIdentifier(param.Name)}");
            }

            sb.AppendLine(")");
            sb.AppendLine("        {");

            // Method body - call the original method
            if (method.IsStatic)
            {
                GenerateStaticMethodCall(sb, node);
            }
            else
            {
                // For instance methods, we need to note they require a reference
                sb.AppendLine($"            // NOTE: This is an instance method from {node.ContainingType?.Name}.");
                sb.AppendLine($"            // You need a reference to the containing behaviour to call this method.");
                sb.AppendLine($"            throw new NotImplementedException(\"Instance method - requires behaviour reference\");");
            }

            sb.AppendLine("        }");
        }

        private static void GenerateStaticMethodCall(StringBuilder sb, NodeDefinition node)
        {
            var method = node.Method;
            var returnType = method.ReturnType;

            sb.Append("            ");

            if (returnType != typeof(void))
            {
                sb.Append("return ");
            }

            sb.Append($"{node.ContainingType?.FullName ?? "Unknown"}.{method.Name}(");

            var parameters = method.GetParameters();
            for (int i = 0; i < parameters.Length; i++)
            {
                if (i > 0) sb.Append(", ");

                var param = parameters[i];
                if (param.IsOut)
                    sb.Append("out ");
                else if (param.ParameterType.IsByRef)
                    sb.Append("ref ");

                sb.Append(SanitizeIdentifier(param.Name));
            }

            sb.AppendLine(");");
        }

        #endregion

        #region Helpers

        private static void EnsureOutputFolder()
        {
            if (!AssetDatabase.IsValidFolder("Assets/UdonSharpCE"))
            {
                AssetDatabase.CreateFolder("Assets", "UdonSharpCE");
            }
            if (!AssetDatabase.IsValidFolder(OUTPUT_FOLDER))
            {
                AssetDatabase.CreateFolder("Assets/UdonSharpCE", "GeneratedWrappers");
            }
        }

        private static Dictionary<string, List<NodeDefinition>> GroupNodesByCategory(List<NodeDefinition> nodes)
        {
            var result = new Dictionary<string, List<NodeDefinition>>();

            foreach (var node in nodes)
            {
                string category = GetCategory(node.MenuPath);

                if (!result.ContainsKey(category))
                {
                    result[category] = new List<NodeDefinition>();
                }

                result[category].Add(node);
            }

            return result;
        }

        private static string GetCategory(string menuPath)
        {
            if (string.IsNullOrEmpty(menuPath))
                return "Uncategorized";

            int slashIndex = menuPath.IndexOf('/');
            return slashIndex >= 0 ? menuPath.Substring(0, slashIndex) : menuPath;
        }

        private static string SanitizeFileName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return "Unknown";

            var invalid = Path.GetInvalidFileNameChars();
            var sb = new StringBuilder();

            foreach (char c in name)
            {
                if (invalid.Contains(c) || c == '/' || c == ' ')
                    sb.Append('_');
                else
                    sb.Append(c);
            }

            return sb.ToString();
        }

        private static string SanitizeIdentifier(string name)
        {
            if (string.IsNullOrEmpty(name))
                return "_unknown";

            var sb = new StringBuilder();

            // First character must be letter or underscore
            char first = name[0];
            if (!char.IsLetter(first) && first != '_')
                sb.Append('_');

            foreach (char c in name)
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                    sb.Append(c);
                else
                    sb.Append('_');
            }

            // Check for C# keywords
            string result = sb.ToString();
            if (IsReservedKeyword(result))
                return "@" + result;

            return result;
        }

        private static bool IsReservedKeyword(string word)
        {
            var keywords = new HashSet<string>
            {
                "abstract", "as", "base", "bool", "break", "byte", "case", "catch",
                "char", "checked", "class", "const", "continue", "decimal", "default",
                "delegate", "do", "double", "else", "enum", "event", "explicit",
                "extern", "false", "finally", "fixed", "float", "for", "foreach",
                "goto", "if", "implicit", "in", "int", "interface", "internal",
                "is", "lock", "long", "namespace", "new", "null", "object", "operator",
                "out", "override", "params", "private", "protected", "public",
                "readonly", "ref", "return", "sbyte", "sealed", "short", "sizeof",
                "stackalloc", "static", "string", "struct", "switch", "this", "throw",
                "true", "try", "typeof", "uint", "ulong", "unchecked", "unsafe",
                "ushort", "using", "virtual", "void", "volatile", "while"
            };
            return keywords.Contains(word);
        }

        private static string GetTypeName(Type type)
        {
            if (type == null) return "void";

            if (type == typeof(void)) return "void";
            if (type == typeof(int)) return "int";
            if (type == typeof(float)) return "float";
            if (type == typeof(bool)) return "bool";
            if (type == typeof(string)) return "string";
            if (type == typeof(double)) return "double";
            if (type == typeof(byte)) return "byte";
            if (type == typeof(sbyte)) return "sbyte";
            if (type == typeof(short)) return "short";
            if (type == typeof(ushort)) return "ushort";
            if (type == typeof(uint)) return "uint";
            if (type == typeof(long)) return "long";
            if (type == typeof(ulong)) return "ulong";
            if (type == typeof(char)) return "char";
            if (type == typeof(object)) return "object";

            if (type.IsArray)
            {
                return GetTypeName(type.GetElementType()) + "[]";
            }

            if (type.IsByRef)
            {
                return GetTypeName(type.GetElementType());
            }

            // For Unity types, use full name
            if (type.Namespace?.StartsWith("UnityEngine") == true)
            {
                return type.FullName;
            }

            // For VRC types, use full name
            if (type.Namespace?.StartsWith("VRC") == true)
            {
                return type.FullName;
            }

            return type.Name;
        }

        private static string GetDefaultValueString(Type type)
        {
            if (type == typeof(int)) return "0";
            if (type == typeof(float)) return "0f";
            if (type == typeof(bool)) return "false";
            if (type == typeof(string)) return "\"\"";
            if (type == typeof(double)) return "0.0";
            if (type == typeof(byte)) return "0";
            if (type == typeof(Vector2)) return "Vector2.zero";
            if (type == typeof(Vector3)) return "Vector3.zero";
            if (type == typeof(Vector4)) return "Vector4.zero";
            if (type == typeof(Quaternion)) return "Quaternion.identity";
            if (type == typeof(Color)) return "Color.white";

            if (type.IsArray)
            {
                return "null";
            }

            if (type.IsValueType)
            {
                return $"default({GetTypeName(type)})";
            }

            return "null";
        }

        #endregion
    }
}

